#! /usr/bin/perl
# vim:et:sw=4:ts=4

use strict;
use Getopt::Long qw(:config no_ignore_case bundling);
use File::Basename;
use LWP::UserAgent;

our $VERSION = '1.2.0';
our %Config = (
    debug => 0,

    # naemon perfdata settings
    timefactor => 9,
    separator => "",
    perfformat => "",
    perfdelimiter => "",

    # feature enabling flags
    attributeparser => 0,

    # influxdb measurement name settings
    global_prefix => "",
    trimpattern => undef,
    threshold_prefix => "",
    threshold_suffix => "",
    range_prefix => "",
    range_suffix => "",

    # influxdb field key settings
    timereplacement => "Time",
    warn_lower_prefix => "",
    warn_lower_suffix => ".warn_lower",
    warn_upper_prefix => "",
    warn_upper_suffix => ".warn_upper",
    crit_lower_prefix => "",
    crit_lower_suffix => ".crit_lower",
    crit_upper_prefix => "",
    crit_upper_suffix => ".crit_upper",
    min_prefix => "",
    min_suffix => ".min",
    max_prefix => "",
    max_suffix => ".max",

    # influxdb server settings
    database => "",  # v1 only
    username => "",  # v1 only
    password => "",  # v1 only
    org      => "",  # v2 only
    backet   => "",  # v2 only
    token    => "",  # v2 only
    apiver   => 1,
    output   => "http://localhost:8086/",
);

our $OS_ERROR;

our $PRESERVE;
our $DRYRUN;

our %LogLvl = (
    "Decode"   => 64,
    "Data"     => 32,
    "Debug"    => 16,
    "Settings" => 8,
    "Files"    => 4,
    "Output"   => 2,
    "HTTP"     => 1,
);

sub Usage {
	my $prog = basename($0);
	print "$prog\t[-d|--debug debug] [-D|--perfdata file]\n";
	print "\t\t[-f|--file file] [-n|--preserve] [-N|--dryrun]\n";
	print "\t\t[-T|--timefactor]\n";
	print "$prog [-h|--help]\n";
}

sub checkFile {
    my ($type, $filename) = @_;
    die "No $type file specified\n" unless ($filename);
    die "$filename: file not found\n" unless (-e $filename);
    die "$filename: permission denied\n" unless (-r $filename);
}

sub Log {
    my ($lvl, $msg) = @_;
    my $prog = basename($0);
    if ($Config{debug} & $lvl) { printf STDERR "[%3d] %s: %s\n", $lvl, $prog, $msg; };
}

sub cmdlineOverride {
    my ($debug, $perfdata, $timefactor) = @_;
    $Config{debug} = $debug if ($debug);
    $Config{perfdata} = $perfdata if ($perfdata);
    $Config{timefactor} = $timefactor if ($timefactor);
}

sub readConfig {
    my ($filename) = @_;
    open my $FH, '<', $filename or ## no critic (RequireBriefOpen)
        die "cannot open $filename: $OS_ERROR, stopped";
    my ($key, $val);
    while (<$FH>) {
        next if /^\s*#/;        # skip commented lines
        s/^\s+//;               # removes leading whitespace
        /^([^=]+)\s*=\s*(.*)$/x and do { # splits into key=val pairs
            $key = $1;
            $val = $2;
            $key =~ s/\s+$//;   # removes trailing whitespace
            $val =~ s/\s+$//;   # removes trailing whitespace
            $Config{$key} = $val;
        };
    }
    close $FH or return "close failed for $filename: $OS_ERROR";
    Log $LogLvl{Files}, "Config:$filename";
}

sub output_v1 {
    my $data = shift;
    my $ua = LWP::UserAgent->new;
     
    my $server_endpoint = $Config{output}."/write?db=".$Config{database}."&u=".$Config{username}."&p=".$Config{password};
    my $req = HTTP::Request->new(POST => $server_endpoint);
    Log $LogLvl{Output}, $data;
     
    # add POST data to HTTP request body
    if  ($DRYRUN) {
        Log $LogLvl{HTTP}, sprintf "%s [%s] (%d)", $server_endpoint, "-0-", length($data);
	print $data, "\n";
        return 1;
    }

    $req->content($data);
    my $resp = $ua->request($req);
    if ($resp->is_success) {
        my $message = $resp->decoded_content;
        Log $LogLvl{HTTP}, sprintf "%s [%s] (%d)", $server_endpoint, $resp->code, length($data);
	return 1;
    }
    else {
        print STDERR "HTTP POST error code: ", $resp->code, "\n";
        print STDERR "HTTP POST error message: ", $resp->message, "\n", $data, "\n";
	return undef;
    }
}

sub output_v2 {
    my $data = shift;
    my $ua = LWP::UserAgent->new;
     
    my $server_endpoint = $Config{output}."/api/v2/write?org=".$Config{org}."&bucket=".$Config{bucket};
    my $req = HTTP::Request->new(POST => $server_endpoint);
    $req->header("Authorization" => "Token ".$Config{token});
    $req->header("Content-Type"  => "text/plain; charset=utf-8");
    $req->header("Accept"        => "application/json");
    Log $LogLvl{Output}, $data;
     
    # add POST data to HTTP request body
    if  ($DRYRUN) {
        Log $LogLvl{HTTP}, sprintf "%s [%s] (%d)", $server_endpoint, "-0-", length($data);
	print $data, "\n";
        return 1;
    }

    $req->content($data);
    my $resp = $ua->request($req);
    if ($resp->is_success) {
        my $message = $resp->decoded_content;
        Log $LogLvl{HTTP}, sprintf "%s [%s] (%d)", $server_endpoint, $resp->code, length($data);
	return 1;
    }
    else {
        print "DEBUG3: ", $resp->content, "\n";
        print STDERR "HTTP POST error code: ", $resp->code, "\n";
        print STDERR "HTTP POST error message: ", $resp->message, "\n", $data, "\n";
	return undef;
    }
}

sub output {
    my $data = shift;

    if    ( $Config{apiver} == 1 ){
	return output_v1( $data );
    }elsif( $Config{apiver} == 2 ){
	return output_v2( $data );
    }else{
        Log $LogLvl{HTTP}, "Unknown protocol version (%d).", $Config{apiver};
	return undef;
    }
}

sub parseFormat {
    my ($fmt, $delim) = @_;
    my @c;
    my $i = 0;
    Log $LogLvl{Debug}, "Delim:$delim.";
    foreach (split /$delim/, $fmt) {
        if (/^tag=(.*)/) { 
            $c[$i]{type} = "tag";
            $c[$i]{tag} = $1;
        }
        elsif ($_) {
            $c[$i]{type} = $_;
        }
        else {
            $c[$i]{type} = "blank";
        }
        Log $LogLvl{Debug}, sprintf ("Column %d:%s%s.", $i, $c[$i]{type}, ($c[$i]{type} eq "tag") ? "=".$c[$i]{tag} : "");
        $i++;
    }
    return @c;
}

sub processThreshold {
    my ($t) = @_;
    if    ( $t =~ m/^\@?([.+-\d]+)$/ ){
	return (0, $1);
    }elsif( $t =~ m/^\@?([.+-\d]+):$/ ){
	return ($1, undef);
    }elsif( $t =~ m/^\@?~:([.+-\d]+)$/ ){
	return (undef, $1);
    }elsif( $t =~ m/^\@?([.+-\d]+):([.+-\d]+)$/ ){
	return ($1, $2);
    }else{
	return (undef, undef);
    }
}

sub processMeasurements {
    my ($raw) = @_;
    my @metric;
    my @threshold;
    my @range;
    my $warn_lower_prefix = $Config{warn_lower_prefix};
    my $warn_lower_suffix = $Config{warn_lower_suffix};
    my $warn_upper_prefix = $Config{warn_upper_prefix};
    my $warn_upper_suffix = $Config{warn_upper_suffix};
    my $crit_lower_prefix = $Config{crit_lower_prefix};
    my $crit_lower_suffix = $Config{crit_lower_suffix};
    my $crit_upper_prefix = $Config{crit_upper_prefix};
    my $crit_upper_suffix = $Config{crit_upper_suffix};
    my $min_prefix = $Config{min_prefix};
    my $min_suffix = $Config{min_suffix};
    my $max_prefix = $Config{max_prefix};
    my $max_suffix = $Config{max_suffix};
    foreach (split /\s/, $raw) {
        my ($key,$val) = split /=/, $_, 2;
        my @data = split /;/, $val;
        Log $LogLvl{Decode}, $key."=".$data[0];
        $data[0] =~ m/([.+-\d]*)(.*)/;
        my $units = $2;
        my $factor = 1;
        $factor = 1000 if ($units eq "ms");
        $factor = 1000000 if ($units eq "us");
        $data[0] = $1/$factor;
        $key = $Config{timereplacement} if ($key eq "time" && $Config{timereplacement});
        push @metric, $key."=".$data[0];
	my ($warn_lower, $warn_upper) = processThreshold( $data[1] );
	my ($crit_lower, $crit_upper) = processThreshold( $data[2] );
	my $min = $data[3];
	my $max = $data[4];
	push @threshold, "$warn_lower_prefix$key$warn_lower_suffix=$warn_lower" if defined $warn_lower;
	push @threshold, "$warn_upper_prefix$key$warn_upper_suffix=$warn_upper" if defined $warn_upper;
	push @threshold, "$crit_lower_prefix$key$crit_lower_suffix=$crit_lower" if defined $crit_lower;
	push @threshold, "$crit_upper_prefix$key$crit_upper_suffix=$crit_upper" if defined $crit_upper;
	push @range, "$min_prefix$key$min_suffix=$min" if $min ne '';
	push @range, "$max_prefix$key$max_suffix=$max" if $max ne '';
    }
    return \@metric, \@threshold, \@range;
}

sub processDataline {
    my ($l, $delim, @perfformat) = @_;
    my $trimpattern = $Config{trimpattern} ? qr"$Config{trimpattern}" : undef;
    my $tsp = "";
    my $tag = "";

    my ($metric, $threshold, $range);

    my $label;
    my @datafield = split /$delim/, $l;
    for( my $i = 0; $i < @datafield; $i++ ){
	my $f = $datafield[$i];
	my $type_of_column = lc $perfformat[$i]->{type};
	my $tag_of_column  = lc $perfformat[$i]->{tag};
	
        next unless $type_of_column;
        if ($type_of_column eq "label") {
            $f =~ s/ /$Config{separator}/g;
            $f =~ s/$trimpattern//g if $trimpattern;
            $label .= "." if $label ne "";
            $label .= $f;
        }elsif ($type_of_column eq "tag") {
            return if $tag_of_column eq "state" && $_ eq "UNKNOWN";
            $f =~ s/ /$Config{separator}/g;
            $tag .= "," if $tag ne "";
	    $tag .= "$tag_of_column=$f";
        }elsif ($type_of_column eq "time") {
            $tsp = $f * (10 ** $Config{timefactor});
        }elsif ($type_of_column eq "data") {
    	    ($metric, $threshold, $range) = processMeasurements($f);
        } 
    }

    my $global_prefix = $Config{global_prefix};
    my $threshold_prefix = $Config{threshold_prefix};
    my $threshold_suffix = $Config{threshold_suffix};
    my $range_prefix = $Config{range_prefix};
    my $range_suffix = $Config{range_suffix};
    my @data;
    $global_prefix .= "." if $global_prefix ne '' && $global_prefix !~ m/\.$/;
    foreach (@$metric) {
	my $currtag = ",$tag" if $tag ne "";
	if( $Config{attributeparser} ){
		s{(\w+)\[([-+*/.:\w]+)\]}{
			$currtag .= ",$1=$2";
			$1;
		}egx;
	}
        push @data, "$global_prefix$label$currtag $_ $tsp";
    }
    foreach (@$threshold) {
	my $currtag = $tag;
	if( $Config{attributeparser} ){
		s{(\w+)\[([-+*/.:\w]+)\]}{
			$currtag .= ',' if $currtag;
			$currtag .= "$1=$2";
			$1;
		}egx;
	}
        push @data, "$global_prefix$threshold_prefix$label$threshold_suffix$currtag $_ $tsp";
    }
    foreach (@$range) {
	my $currtag = $tag;
	if( $Config{attributeparser} ){
		s{(\w+)\[([-+*/.:\w]+)\]}{
			$currtag .= ',' if $currtag;
			$currtag .= "$1=$2";
			$1;
		}egx;
	}
        push @data, "$global_prefix$range_prefix$label$range_suffix$currtag $_ $tsp";
    }
    return join "\n", @data;
}

sub processDatafile {
    my ($filename, $delim, @perfformat) = @_;
    my @data;

    open DATA, '<', $filename or die "$filename: $!\n";
    Log $LogLvl{Files}, "Reading $filename ...";
    while(<DATA>) {
        chomp;
        Log $LogLvl{Data}, "$_";
        my $data = processDataline($_, $delim, @perfformat);
    	push @data, $data if $data;
    }
    close DATA;
    return @data;
}

sub process {
    my ($filename) = @_;
    my @perfformat = parseFormat($Config{perfformat}, $Config{perfdelimiter});
    checkFile("data", $filename);

    my $datafile = $filename;
    unless ($PRESERVE || $DRYRUN) {
	$datafile = $filename.".".$$;
        Log $LogLvl{Files}, "Renaming $filename to $datafile";
        rename $filename, $datafile or die "Renaming $filename: $!\n";    
    }

    my @data = processDatafile($datafile, $Config{perfdelimiter}, @perfformat);
    my $ok = output( join "\n", @data );
    unless ($ok) {
	my ($h, $i);
	open $h, '>>', "$filename.failed" and do {
	    open $i, '<', $datafile and do {
		while( <$i> ){ print $h $_; }
		close $i;
	    };
	    close $h;
	};
    }
    unless ($PRESERVE || $DRYRUN) {
        Log $LogLvl{Files}, "Removing $datafile";
        unlink $datafile;
    }
}



my $configfile = '/etc/naemon/naemon2influx.cfg';
my $help;
my $timefactor;
my $debug;
my $perfdata;

GetOptions (
    "d|debug=s"    => \$debug,
    "f|file=s"     => \$configfile,
    "D|perfdata=s" => \$perfdata,
    "h|help"       => \$help,
    "n|preserve"   => \$PRESERVE,
    "N|dryrun"     => \$DRYRUN,
    "T|timefactor" => \$timefactor)
    or die("Error in command line arguments\n");

if ($help) {
	Usage();
	exit 1;
}

checkFile("config", $configfile);

readConfig($configfile);
cmdlineOverride($debug, $perfdata, $timefactor);

Log ($LogLvl{Settings}, "--");
Log ($LogLvl{Settings}, "$_=$Config{$_}") for (keys %Config);
Log ($LogLvl{Settings}, "--");

process($Config{perfdata});

=pod

=encoding utf8

=head1 naemon2influx

Write naemon perforance data directly to InfluxDB.

=head1 SYNOPSIS

 naemon2influx [-d|--debug debug] [-D|--perfdata file]
          [-f|--file file] [-n|--preserve] [-N|--dryrun]
          [-T|--timefactor]

 naemon2influx [-h|--help]

=head1 DESCRIPTION

Nagios is great. InfluxDB is great. While you are performing service 
checks in Nagios they are (probably) creating performance data as a 
by-product. If not you might as well be. 

There are mechanisms for inserting this data into InfluxDB's time 
series database, but htere have their limitations, and most involve 
going through some form of graphite-like interface. naemon2influx 
bypasses graphite and writes directly to InfluxDB using either of 
the native udp or tcp interfaces. 

naemon2influx parses Nagios produced performance data and constructs 
InfluxDB line format metrics, readly to be set to InfluxDB's UDP 
listener (via stdout to be subsequently piped), or TCP listener.

=head1 OPTIONS

=over 8

=item B<-d>|B<--debug> B<debug level>>

This sets the verbosity level of the debug output. 

Debug output is written to stderr, it is left to the caller to 
redirect the debug output to a suitable log file.


Debug level is a bit mask. Default is 0 (silent).

  1: HTTP summary
  2: InfluxDB line format output
  4: file access
  8: configuration settings
 16: deconstruction of the perfdata line format
 32: displays raw perfdata line
 64: displays the prefdata parsed into separate metrics.

See B<Examples>.

=item B<-D>|B<--perfdata> B<file>

Specify the locaction of the naemon performancer data file.

=item B<-f>|B<--file> B<file>

Specify the locaction of the configuration file. 
Default /etc/naemon/naemon2influx.cfg.

=item B<-n>|B<--preserve>

The normal operation is to move the performance datafile to a 
new file, appending the process id to the performace data file,
and to delete this file once processing is complete.

The option processes the file in-place, leaving it intact for 
further processing. It is expected that this further processing
will delete or truncate the datfile thus ensuring that the same
data is not processes again on sebsequent runs.

=item B<-N>|B<--dryrun>

Implies B<-n>. No data is written to InfluxDB. Used for debugging
configuration.  If the configuration would ordinarily post to HTTP,
the return status code is listed as 0.

=item B<-T>|B<--timefactor> I<N>

Default 9. Nagios writes performance data timestamped by epoch seconds.
InfluxDB expects epoch nanoseconds, this is a difference of 9 orders
of magnitude. Nagios timestamps are multipled by 10 to the power
of this value.

=back

=head1 EXAMPLES

To run using a test configuration file, preserving the test datafile,
display configuration settings and decoded metrics.

naemon2influx -D perfdata.out -f naemon2influx.test -N -d 72

To write to InfluxDB's UDP listener on port 8086, while directing the
debug information (file access and configuration settings) to a log file.

naemon2influx -d12 2> /var/log/naemon2influx.log | nc -u localhost 8086

=head1 ENVIRONMENT

None.

=head1 FILES

=over 8

=item F</etc/naemon/naemon2influx.cfg>

=back

=head1 AUTHOR

Andrew Pickin

=head1 SEE ALSO

L<naemon2influx.cfg(5)>

